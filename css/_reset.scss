
// Requires several helper functions including: pow, calc-interpolation, cubic-bezier, number and explode

// Math functions:

// Linear interpolations in CSS as a Sass function
// Author: Mike Riethmuller | https://madebymike.com.au/writing/precise-control-responsive-typography/ I

@function calc-interpolation($min-screen, $min-value, $max-screen, $max-value) {
	$a : ($max-value - $min-value) / ($max-screen - $min-screen);
	$b : $min-value - $a * $min-screen;
	$sign : "+";

	@if ($b < 0) {
		$sign : "-";
		$b : abs($b);
	}

	@return calc(#{$a*100}vw #{$sign} #{$b});
}

// This is a crude Sass port webkits cubic-bezier function. Looking to simplify this if you can help.
@function solve-bexier-x($p1x, $p1y, $p2x, $p2y, $x) {
	$cx : 3.0 * $p1x;
	$bx : 3.0 * ($p2x - $p1x) - $cx;
	$ax : 1.0 - $cx -$bx;
	$t0 : 0.0;
	$t1 : 1.0;
	$t2 : $x;
	$x2 : 0;
	$res : 1000;

	@while ($t0 < $t1 or $break) {
		$x2 : (($ax * $t2 + $bx) * $t2 + $cx) * $t2;

		@if (abs($x2 - $x) < $res) {
			@return $t2;
		}

		@if ($x > $x2) {
			$t0 : $t2;
		}

		@else {
			$t1 : $t2;
		}

		$t2 : ($t1 - $t0) * 0.5+$t0;
	}

	@return $t2;
}

@function cubic-bezier($p1x, $p1y, $p2x, $p2y, $x) {
	$cy : 3.0 * $p1y;
	$by : 3.0 * ($p2y - $p1y) - $cy;
	$ay : 1.0 - $cy - $by;
	$t : solve-bexier-x($p1x, $p1y, $p2x, $p2y, $x);
	@return (($ay * $t + $by) * $t + $cy) * $t;
}

// A stright up lerp
// Credit: Ancient Greeks possibly Hipparchus of Rhodes
@function lerp($a, $b, $t) {
	@return $a+($b - $a) * $t;
}

// String functions:

// Cast string to number
// Credit: Hugo Giraudel | https://www.sassmeister.com/gist/9fa19d254864f33d4a80
@function number($value) {
	@if type-of($value)=="number" {
		@return $value;
	}

	@else if type-of($value) !="string" {
		$_ : log("Value for `to-number` should be a number or a string.");
	}

	$result : 0;
	$digits : 0;
	$minus : str-slice($value, 1, 1)=="-";
	$numbers : ("0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9);

	@for $i from if($minus, 2, 1) through str-length($value) {
		$character : str-slice($value, $i, $i);

		@if not (index(map-keys($numbers), $character) or $character==".") {
			@return to-length(if($minus, -$result, $result), str-slice($value, $i))
		}

		@if $character=="." {
			$digits : 1;
		}

		@else if $digits==0 {
			$result : $result * 10 + map-get($numbers, $character);
		}

		@else {
			$digits : $digits * 10;
			$result : $result + map-get($numbers, $character) / $digits;
		}
	}

	@return if($minus, -$result, $result);
	;
}

// Explode a string by a delimiter
// Credit: https://gist.github.com/danielpchen/3677421ea15dcf2579ff
@function explode($string, $delimiter) {
	$result : ();

	@if $delimiter=="" {
		@for $i from 1 through str-length($string) {
			$result : append($result, str-slice($string, $i, $i));
		}

		@return $result;
	}

	$exploding : true;

	@while $exploding {
		$d-index : str-index($string, $delimiter);

		@if $d-index {
			@if $d-index>1 {
				$result : append($result, str-slice($string, 1, $d-index - 1));
				$string : str-slice($string, $d-index + str-length($delimiter));
			}

			@else if $d-index==1 {
				$string : str-slice($string, 1, $d-index + str-length($delimiter));
			}

			@else {
				$result : append($result, $string);
				$exploding : false;
			}
		}

		@else {
			$result : append($result, $string);
			$exploding : false;
		}
	}

	@return $result;
}


html ,
body ,
div ,
span ,
applet ,
object ,
iframe ,
h1 ,
h2 ,
h3 ,
h4 ,
h5 ,
h6 ,
p ,
blockquote ,
pre ,
a ,
abbr ,
acronym ,
address ,
big ,
cite ,
code ,
del ,
dfn ,
em ,
img ,
ins ,
kbd ,
q ,
s ,
samp ,
small ,
strike ,
strong ,
sub ,
sup ,
tt ,
var ,
b ,
u ,
i ,
center ,
dl ,
dt ,
dd ,
ol ,
ul ,
li ,
fieldset ,
form ,
label ,
legend ,
table ,
caption ,
tbody ,
tfoot ,
thead ,
tr ,
th ,
td ,
article ,
aside ,
canvas ,
details ,
embed ,
figure ,
figcaption ,
footer ,
header ,
hgroup ,
menu ,
nav ,
output ,
ruby ,
section ,
summary ,
time ,
mark ,
audio ,
video {
	margin : 0;
	padding : 0;
	border : 0;
	font-size : 100%;
	font : inherit;
	vertical-align : baseline;
}

/* HTML5 display-role reset for older browsers */
article ,
aside ,
details ,
figcaption ,
figure ,
footer ,
header ,
hgroup ,
menu ,
nav ,
section {
	display : block;
}

body {
	line-height : 1;
}

ol ,
ul {
	list-style : none;
}

blockquote ,
q {
	quotes : none;
}

blockquote:before ,
blockquote:after ,
q:before ,
q:after {
	content : "";
	content : none;
}

table {
	border-collapse : collapse;
	border-spacing : 0;
}

textarea {
	resize : none;
}


* {
	& ,
	&:after ,
	&:before {
		background-repeat : no-repeat;
		box-sizing : border-box;
	}
}

a {
	color: inherit;
	& ,
	&:hover ,
	&:focus {
		text-decoration : none;
	}

	& {
		display : inline-block;
	}
}

button ,
input ,
textarea {
	&:focus ,
	&:hover {
		outline : 0;
	}
}

img {
	vertical-align : middle;
	border-style : none;
	max-width : 100%;
	height : auto;
}

svg {
	overflow : hidden;
	vertical-align : middle;
}

html {
	scroll-behavior : smooth;
}





//clearing floats
.clearfix {
	overflow : visible;

	&::after {
		content : "";
		clear : both;
		display : block;
	}
}

.hidden {
	display : none !important;
}